package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/bclswl0827/openstation/drivers/dao/tables"
	"github.com/bclswl0827/openstation/drivers/gnss"
	"github.com/bclswl0827/openstation/drivers/pan_tilt"
	"github.com/bclswl0827/openstation/drivers/tle"
	"github.com/bclswl0827/openstation/graph/model"
	"github.com/bclswl0827/openstation/startups"
	"github.com/bclswl0827/openstation/startups/alignment"
	"github.com/bclswl0827/openstation/utils/logger"
	"github.com/bclswl0827/openstation/utils/system"
	"gorm.io/gorm"
)

// SetPanTilt is the resolver for the setPanTilt field.
func (r *mutationResolver) SetPanTilt(ctx context.Context, newPan float64, newTilt float64) (bool, error) {
	// Apply new pan and tilt angles
	err := r.Dependency.Invoke(func(deps *pan_tilt.PanTiltDependency) error {
		driver := pan_tilt.PanTiltDriver(&pan_tilt.PanTiltDriverImpl{})
		err := driver.SetPan(deps, newPan)
		if err != nil {
			return err
		}
		err = driver.SetTilt(deps, newTilt)
		if err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		logger.GetLogger(r.SetPanTilt).Warn(err)
		return false, err
	}

	return true, nil
}

// SetPanTiltOffset is the resolver for the setPanTiltOffset field.
func (r *mutationResolver) SetPanTiltOffset(ctx context.Context, newOffset float64) (bool, error) {
	err := r.Dependency.Invoke(func(deps *pan_tilt.PanTiltDependency) error {
		if deps.IsBusy {
			return errors.New("cannot set offset while Pan-Tilt is busy")
		}
		deps.NorthOffset = newOffset
		return nil
	})
	if err != nil {
		logger.GetLogger(r.SetPanTiltToNorth).Warn(err)
		return false, err
	}

	return true, nil
}

// SetPanTiltToNorth is the resolver for the SetPanTiltToNorth field.
func (r *mutationResolver) SetPanTiltToNorth(ctx context.Context) (bool, error) {
	err := r.Dependency.Invoke(func(deps *pan_tilt.PanTiltDependency) error {
		if deps.IsBusy {
			return errors.New("cannot set Pan-Tilt to north while it is busy")
		}
		return nil
	})
	if err != nil {
		logger.GetLogger(r.SetPanTiltToNorth).Warn(err)
		return false, err
	}

	// Use alignment task in startup directly
	var alignment alignment.AlignmentStartupTask
	go alignment.Execute(r.Dependency, &startups.Options{
		Config:   r.Config,
		Database: r.Database,
	})

	return true, nil
}

// ImportTLEs is the resolver for the ImportTLEs field.
func (r *mutationResolver) ImportTLEs(ctx context.Context, tleData string) (int, error) {
	// Get current time from GNSS
	var currentTime time.Time
	err := r.Dependency.Invoke(func(deps *gnss.GnssDependency) error {
		t, err := deps.State.Time.GetTime()
		if err != nil {
			return err
		}
		currentTime = t
		return nil
	})
	if err != nil {
		logger.GetLogger(r.ImportTLEs).Warn(err)
		return 0, err
	}

	// Split TLE data into groups
	tleDataArr := strings.Split(tleData, "\n")
	var tleDataGroup []string
	for i := 0; i < len(tleDataArr); i += 3 {
		if i+3 > len(tleDataArr) {
			break
		}
		tleDataGroup = append(tleDataGroup, strings.Join(tleDataArr[i:i+3], "\n"))
	}

	// Insert TLE records to database
	var failedTLECount int
	err = r.Database.Transaction(func(tx *gorm.DB) error {
		// Parse and insert each TLE record by group
		for _, tleInput := range tleDataGroup {
			var inputTLE tle.TLE
			err := inputTLE.Load(tleInput)
			if err != nil {
				failedTLECount++
				continue
			}
			var inputSatellite tle.Satellite
			err = inputSatellite.Parse(&inputTLE, &tle.Observer{}, currentTime, 0)
			if err != nil {
				failedTLECount++
				continue
			}

			// Insert record if not exists, otherwise update
			record := tables.SatelliteTLE{
				ID:            inputTLE.ID,
				Name:          inputTLE.Name,
				Line_1:        inputTLE.Line_1,
				Line_2:        inputTLE.Line_2,
				Geostationary: inputSatellite.Geostationary,
				EpochTime:     inputSatellite.EpochTime.UnixMilli(),
			}
			err = tx.
				Table(record.GetName()).
				Where("id = ?", record.ID).
				Assign(record).
				FirstOrCreate(&record).
				Error
			if err != nil {
				failedTLECount++
			}
		}

		return nil
	})
	if err != nil {
		logger.GetLogger(r.ImportTLEs).Warn(err)
		return -1, err
	}

	if failedTLECount == len(tleDataGroup) {
		err := errors.New("all TLE records are failed to import")
		logger.GetLogger(r.ImportTLEs).Warn(err)
		return -1, err
	}
	return failedTLECount, nil
}

// AddNewTle is the resolver for the AddNewTLE field.
func (r *mutationResolver) AddNewTle(ctx context.Context, tleData string) (bool, error) {
	// Get current time from GNSS
	var currentTime time.Time
	err := r.Dependency.Invoke(func(deps *gnss.GnssDependency) error {
		t, err := deps.State.Time.GetTime()
		if err != nil {
			return err
		}
		currentTime = t
		return nil
	})
	if err != nil {
		logger.GetLogger(r.AddNewTle).Warn(err)
		return false, err
	}

	// Parse input TLE data
	var inputTLE tle.TLE
	err = inputTLE.Load(tleData)
	if err != nil {
		logger.GetLogger(r.AddNewTle).Warn(err)
		return false, err
	}
	var inputSatellite tle.Satellite
	err = inputSatellite.Parse(&inputTLE, &tle.Observer{}, currentTime, 0)
	if err != nil {
		logger.GetLogger(r.AddNewTle).Warn(err)
		return false, err
	}

	// Insert TLE record to database
	tleRecord := tables.SatelliteTLE{
		ID:            inputTLE.ID,
		Name:          inputTLE.Name,
		Line_1:        inputTLE.Line_1,
		Line_2:        inputTLE.Line_2,
		EpochTime:     inputSatellite.EpochTime.UnixMilli(),
		Geostationary: inputSatellite.Geostationary,
	}
	err = r.Database.
		Table(tleRecord.GetName()).
		Create(&tleRecord).
		Error
	if err != nil {
		logger.GetLogger(r.AddNewTle).Warn(err)
		return false, err
	}

	return true, nil
}

// DeleteTLEByID is the resolver for the DeleteTLEById field.
func (r *mutationResolver) DeleteTLEByID(ctx context.Context, tleID int64) (bool, error) {
	var tleModel tables.SatelliteTLE
	err := r.Database.
		Table(tleModel.GetName()).
		Where("id = ?", tleID).
		Delete(tleModel).
		Error
	if err != nil {
		logger.GetLogger(r.DeleteTLEByID).Warn(err)
		return false, err
	}

	return true, nil
}

// UpdateTLEByID is the resolver for the UpdateTLEById field.
func (r *mutationResolver) UpdateTLEByID(ctx context.Context, tleID int64, tleData string) (bool, error) {
	// Check TLE record existence
	var (
		tleModel  tables.SatelliteTLE
		tleRecord tables.SatelliteTLE
	)
	err := r.Database.
		Table(tleModel.GetName()).
		Where("id = ?", tleID).
		First(&tleRecord).
		Error
	if err != nil {
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	}
	if len(tleRecord.Line_1) == 0 || len(tleRecord.Line_2) == 0 {
		err = errors.New("no matching TLE record found")
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	}

	// Load input TLE data, compare their ID
	var inputTLE tle.TLE
	err = inputTLE.Load(tleData)
	if err != nil {
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	} else if inputTLE.ID != tleID {
		err = errors.New("input TLE ID and record ID do not match")
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	}

	// Get current time from GNSS
	var currentTime time.Time
	err = r.Dependency.Invoke(func(deps *gnss.GnssDependency) error {
		t, err := deps.State.Time.GetTime()
		if err != nil {
			return err
		}
		currentTime = t
		return nil
	})
	if err != nil {
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	}

	// Parse input TLE data
	var inputSatellite tle.Satellite
	err = inputSatellite.Parse(&inputTLE, &tle.Observer{}, currentTime, 0)
	if err != nil {
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	}

	// Update TLE record
	tleRecord.Name = inputTLE.Name
	tleRecord.Line_1 = inputTLE.Line_1
	tleRecord.Line_2 = inputTLE.Line_2
	tleRecord.EpochTime = inputSatellite.EpochTime.UnixMilli()
	tleRecord.Geostationary = inputSatellite.Geostationary
	err = r.Database.
		Table(tleModel.GetName()).
		Where("id = ?", tleID).
		Updates(tleRecord).
		Error
	if err != nil {
		logger.GetLogger(r.UpdateTLEByID).Warn(err)
		return false, err
	}

	return true, nil
}

// AddNewTask is the resolver for the addNewTask field.
func (r *mutationResolver) AddNewTask(ctx context.Context, tleID int64, startTime int64, endTime int64, webhook string) (bool, error) {
	panic(fmt.Errorf("not implemented: AddNewTask - addNewTask"))
}

// DeleteTaskByID is the resolver for the deleteTaskById field.
func (r *mutationResolver) DeleteTaskByID(ctx context.Context, taskID int64) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTaskByID - deleteTaskById"))
}

// RebootSystem is the resolver for the RebootSystem field.
func (r *mutationResolver) RebootSystem(ctx context.Context) (bool, error) {
	go func() {
		time.Sleep(time.Second * 3)
		system.Reboot()
	}()

	return true, nil
}

// PurgeTaskQueue is the resolver for the PurgeTaskQueue field.
func (r *mutationResolver) PurgeTaskQueue(ctx context.Context) (bool, error) {
	var taskModel tables.TaskQueue
	err := r.Database.Table(taskModel.GetName()).
		Select("*").
		Where("id = id").
		Delete(&taskModel).
		Error
	if err != nil {
		logger.GetLogger(r.PurgeTaskQueue).Warn(err)
		return false, err
	}

	return true, nil
}

// PurgeTLERecords is the resolver for the PurgeTLERecords field.
func (r *mutationResolver) PurgeTLERecords(ctx context.Context) (bool, error) {
	var tleModel tables.SatelliteTLE
	err := r.Database.Table(tleModel.GetName()).
		Select("*").
		Where("id = id").
		Delete(&tleModel).
		Error
	if err != nil {
		logger.GetLogger(r.PurgeTLERecords).Warn(err)
		return false, err
	}

	return true, nil
}

// GetStation is the resolver for the GetStation field.
func (r *queryResolver) GetStation(ctx context.Context) (*model.Station, error) {
	// Get current time from GNSS
	var currentTime time.Time
	err := r.Dependency.Invoke(func(deps *gnss.GnssDependency) error {
		t, err := deps.State.Time.GetTime()
		if err != nil {
			return err
		}
		currentTime = t
		return nil
	})
	if err != nil {
		logger.GetLogger(r.GetStation).Warn(err)
		return nil, err
	}

	// Get satellite count from database
	var (
		tleModel       tables.SatelliteTLE
		satelliteCount int64
	)
	err = r.Database.
		Table(tleModel.GetName()).
		Count(&satelliteCount).
		Error
	if err != nil {
		logger.GetLogger(r.GetStation).Warn(err)
		return nil, err
	}

	// Get task queue count from database
	var (
		taskModel        tables.TaskQueue
		pendingTaskCount int64
		totalTaskCount   int64
	)
	err = r.Database.
		Table(taskModel.GetName()).
		Count(&totalTaskCount).
		Where("start_time > ?", currentTime.UnixMilli()).
		Count(&pendingTaskCount).
		Error
	if err != nil {
		logger.GetLogger(r.GetStation).Warn(err)
		return nil, err
	}

	return &model.Station{
		PendingTasks: pendingTaskCount,
		TotalTasks:   totalTaskCount,
		Satellites:   satelliteCount,
		Name:         r.Config.Station.Name,
		Location:     r.Config.Station.Location,
		Remarks:      r.Config.Station.Remarks,
		ClockOffset:  int(time.Now().UTC().Sub(currentTime).Seconds()),
	}, nil
}

// GetPanTilt is the resolver for the GetPanTilt field.
func (r *queryResolver) GetPanTilt(ctx context.Context) (*model.PanTilt, error) {
	var panTiltDeps pan_tilt.PanTiltDependency
	r.Dependency.Invoke(func(deps *pan_tilt.PanTiltDependency) {
		panTiltDeps = *deps
	})

	return &model.PanTilt{
		CurrentPan:  panTiltDeps.CurrentPan,
		CurrentTilt: panTiltDeps.CurrentTilt,
		NorthOffset: panTiltDeps.NorthOffset,
		IsBusy:      panTiltDeps.IsBusy,
	}, nil
}

// GetSystem is the resolver for the GetSystem field.
func (r *queryResolver) GetSystem(ctx context.Context) (*model.System, error) {
	uptime, err := system.GetUptime()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	cpuUsage, err := system.GetCPUUsage()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	memUsage, err := system.GetMemUsage()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	diskUsage, err := system.GetDiskUsage()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	release, err := system.GetRelease()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	arch, err := system.GetArch()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	hostname, err := system.GetHostname()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}
	ipAddrs, err := system.GetIPv4Addrs()
	if err != nil {
		logger.GetLogger(r.GetSystem).Warn(err)
		return nil, err
	}

	return &model.System{
		Uptime:    uptime,
		CPUUsage:  cpuUsage,
		MemUsage:  memUsage,
		DiskUsage: diskUsage,
		Release:   release,
		Arch:      arch,
		Hostname:  hostname,
		IP:        ipAddrs,
		Timestamp: time.Now().UTC().UnixMilli(),
	}, nil
}

// GetGnss is the resolver for the getGnss field.
func (r *queryResolver) GetGnss(ctx context.Context) (*model.Gnss, error) {
	var gnssDeps gnss.GnssDependency
	r.Dependency.Invoke(func(deps *gnss.GnssDependency) {
		gnssDeps = *deps
	})

	// Get current time from GNSS dependency
	currentTime, err := gnssDeps.State.Time.GetTime()
	if err != nil {
		logger.GetLogger(r.GetGnss).Warn(err)
		return nil, err
	}

	return &model.Gnss{
		Timestamp:   currentTime.UnixMilli(),
		Latitude:    gnssDeps.State.Latitude,
		Longitude:   gnssDeps.State.Longitude,
		Elevation:   gnssDeps.State.Elevation,
		TrueAzimuth: gnssDeps.State.TrueAzimuth,
		DataQuality: gnssDeps.State.DataQuality,
		Satellites:  gnssDeps.State.Satellites,
	}, nil
}

// GetTLEByID is the resolver for the getTLEById field.
func (r *queryResolver) GetTLEByID(ctx context.Context, tleID int64) (*model.TleData, error) {
	// Get TLE record from database
	var tleRecord tables.SatelliteTLE
	err := r.Database.
		Table(tleRecord.GetName()).
		Where("id = ?", tleID).
		First(&tleRecord).
		Error
	if err != nil {
		logger.GetLogger(r.GetTLEByID).Warn(err)
		return nil, err
	}

	return &model.TleData{
		ID:            tleRecord.ID,
		Name:          tleRecord.Name,
		Line1:         tleRecord.Line_1,
		Line2:         tleRecord.Line_2,
		EpochTime:     tleRecord.EpochTime,
		CreatedAt:     tleRecord.CreatedAt,
		UpdatedAt:     tleRecord.UpdatedAt,
		Geostationary: tleRecord.Geostationary,
	}, nil
}

// GetTLEsByKeyword is the resolver for the getTLEsByKeyword field.
func (r *queryResolver) GetTLEsByKeyword(ctx context.Context, keyword string) ([]*model.TleData, error) {
	// Try to convert keyword to integer
	keywordInNum, _ := strconv.Atoi(keyword)

	// Get all TLE records that match the keyword
	var (
		tleRecords []*tables.SatelliteTLE
		tleModel   tables.SatelliteTLE
	)
	err := r.Database.
		Table(tleModel.GetName()).
		Where("name LIKE ?", "%"+keyword+"%").
		Or("id = ?", keywordInNum).
		Find(&tleRecords).
		Error
	if err != nil {
		logger.GetLogger(r.GetTLEsByKeyword).Warn(err)
		return nil, err
	}

	var tleData []*model.TleData
	for _, record := range tleRecords {
		tleData = append(tleData, &model.TleData{
			ID:            record.ID,
			Name:          record.Name,
			Line1:         record.Line_1,
			Line2:         record.Line_2,
			EpochTime:     record.EpochTime,
			Geostationary: record.Geostationary,
			CreatedAt:     record.CreatedAt,
			UpdatedAt:     record.UpdatedAt,
		})
	}

	return tleData, nil
}

// GetForecastByID is the resolver for the getForecastById field.
func (r *queryResolver) GetForecastByID(ctx context.Context, tleID int64, elevationThreshold float64) ([]*model.Forecast, error) {
	var (
		latitude    float64
		longitude   float64
		altitude    float64
		currentTime time.Time
		tleRecord   tables.SatelliteTLE
	)

	// Get current time from GNSS
	err := r.Dependency.Invoke(func(deps *gnss.GnssDependency) error {
		latitude, longitude, altitude = deps.State.Latitude, deps.State.Longitude, deps.State.Elevation
		t, err := deps.State.Time.GetTime()
		if err != nil {
			return err
		}
		currentTime = t
		return nil
	})
	if err != nil {
		logger.GetLogger(r.GetForecastByID).Warn(err)
		return nil, err
	}

	// Get TLE record from database
	err = r.Database.
		Table(tleRecord.GetName()).
		Where("id = ?", tleID).
		First(&tleRecord).
		Error
	if err != nil {
		logger.GetLogger(r.GetForecastByID).Warn(err)
		return nil, err
	}

	// Check if satellite is geostationary
	if tleRecord.Geostationary {
		err = errors.New("geostationary satellite does not transit")
		logger.GetLogger(r.GetForecastByID).Warn(err)
		return nil, err
	}

	// Get forecast data
	var satelliteTle tle.TLE
	err = satelliteTle.Load(fmt.Sprintf(
		"%s\n%s\n%s",
		tleRecord.Name,
		tleRecord.Line_1,
		tleRecord.Line_2,
	))
	if err != nil {
		logger.GetLogger(r.GetForecastByID).Warn(err)
		return nil, err
	}
	var satelliteObj tle.Satellite
	forecastArr, err := satelliteObj.Predict(&satelliteTle, &tle.Observer{
		Latitude:  latitude,
		Longitude: longitude,
		Altitude:  altitude,
	}, currentTime, currentTime.Add(time.Hour*24), time.Second, elevationThreshold)
	if err != nil {
		logger.GetLogger(r.GetForecastByID).Errorln(err)
	}

	var result []*model.Forecast
	for _, d := range forecastArr {
		result = append(result, &model.Forecast{
			Duration:     d.EndTime.Sub(d.StartTime).Seconds(),
			Latitude:     latitude,
			Longitude:    longitude,
			MaxElevation: d.MaxElevation,
			EntryAzimuth: d.EntryAzimuth,
			ExitAzimuth:  d.ExitAzimuth,
			StartTime:    d.StartTime.UnixMilli(),
			EndTime:      d.EndTime.UnixMilli(),
		})
	}

	return result, nil
}

// GetObservationByID is the resolver for the getObservationById field.
func (r *queryResolver) GetObservationByID(ctx context.Context, tleID int64, elevationThreshold float64) (*model.Observation, error) {
	var (
		latitude    float64
		longitude   float64
		altitude    float64
		currentTime time.Time
		tleRecord   tables.SatelliteTLE
	)

	// Get current time from GNSS
	err := r.Dependency.Invoke(func(deps *gnss.GnssDependency) error {
		latitude, longitude, altitude = deps.State.Latitude, deps.State.Longitude, deps.State.Elevation
		t, err := deps.State.Time.GetTime()
		if err != nil {
			return err
		}
		currentTime = t
		return nil
	})
	if err != nil {
		logger.GetLogger(r.GetObservationByID).Warn(err)
		return nil, err
	}

	// Get TLE record from database
	err = r.Database.
		Table(tleRecord.GetName()).
		Where("id = ?", tleID).
		First(&tleRecord).
		Error
	if err != nil {
		logger.GetLogger(r.GetObservationByID).Warn(err)
		return nil, err
	}

	// Get observation data
	var satelliteTle tle.TLE
	err = satelliteTle.Load(fmt.Sprintf(
		"%s\n%s\n%s",
		tleRecord.Name,
		tleRecord.Line_1,
		tleRecord.Line_2,
	))
	if err != nil {
		logger.GetLogger(r.GetObservationByID).Warn(err)
		return nil, err
	}
	var satelliteObj tle.Satellite
	err = satelliteObj.Parse(&satelliteTle, &tle.Observer{
		Latitude:  latitude,
		Longitude: longitude,
		Altitude:  altitude,
	}, currentTime, elevationThreshold)
	if err != nil {
		logger.GetLogger(r.GetObservationByID).Errorln(err)
		return nil, err
	}

	return &model.Observation{
		Azimuth:    satelliteObj.Azimuth,
		Elevation:  satelliteObj.Elevation,
		Observable: satelliteObj.Observable,
	}, nil
}

// GetTaskByID is the resolver for the getTaskById field.
func (r *queryResolver) GetTaskByID(ctx context.Context, taskID int64) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: GetTaskByID - getTaskById"))
}

// GetTasksByDuration is the resolver for the getTasksByDuration field.
func (r *queryResolver) GetTasksByDuration(ctx context.Context, startTime int64, endTime int64) ([]*model.Task, error) {
	panic(fmt.Errorf("not implemented: GetTasksByDuration - getTasksByDuration"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
